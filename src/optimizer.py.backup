import numpy as np
import pulp
from typing import Dict, List, Tuple
import pandas as pd

class NutritionOptimizer:
    """
    Optimizes daily meal plan using Linear Programming
    to meet nutritional targets within constraints
    """
    
    def __init__(self, foods_df: pd.DataFrame):
        self.foods_df = foods_df
        self.solution = None
        
    def optimize(self, 
                 target_calories: float,
                 target_protein: float,
                 target_carbs: float,
                 target_fat: float,
                 tolerance: float = 0.05) -> Dict:
        """
        Finds optimal food amounts to meet nutritional targets
        
        Args:
            target_calories: Target daily calories
            target_protein: Target protein in grams
            target_carbs: Target carbs in grams
            target_fat: Target fat in grams
            tolerance: Acceptable deviation from targets (5% default)
            
        Returns:
            Dictionary with selected foods and their amounts
        """
        
        # Create optimization problem
        prob = pulp.LpProblem("Nutrition_Optimization", pulp.LpMinimize)
        
        # Decision variables: amount of each food in grams
        food_vars = {}
        for idx, row in self.foods_df.iterrows():
            food_id = row['food_id']
            # Min 0g, Max 500g per food item
            food_vars[food_id] = pulp.LpVariable(
                f"food_{food_id}", 
                lowBound=0, 
                upBound=500
            )
        
        # Objective: Minimize total weight
        prob += pulp.lpSum([food_vars[fid] for fid in food_vars])
        
        # Calculate nutritional values per 100g
        total_calories = pulp.lpSum([
            food_vars[row['food_id']] * row['calories'] / 100
            for idx, row in self.foods_df.iterrows()
        ])
        
        total_protein = pulp.lpSum([
            food_vars[row['food_id']] * row['protein'] / 100
            for idx, row in self.foods_df.iterrows()
        ])
        
        total_carbs = pulp.lpSum([
            food_vars[row['food_id']] * row['carbs'] / 100
            for idx, row in self.foods_df.iterrows()
        ])
        
        total_fat = pulp.lpSum([
            food_vars[row['food_id']] * row['fat'] / 100
            for idx, row in self.foods_df.iterrows()
        ])
        
        # Constraints with tolerance
        prob += total_calories >= target_calories * (1 - tolerance)
        prob += total_calories <= target_calories * (1 + tolerance)
        
        prob += total_protein >= target_protein * (1 - tolerance)
        prob += total_protein <= target_protein * (1 + tolerance)
        
        prob += total_carbs >= target_carbs * (1 - tolerance)
        prob += total_carbs <= target_carbs * (1 + tolerance)
        
        prob += total_fat >= target_fat * (1 - tolerance)
        prob += total_fat <= target_fat * (1 + tolerance)
        
        # Solve
        prob.solve(pulp.PULP_CBC_CMD(msg=0))
        
        # Extract solution
        if prob.status == pulp.LpStatusOptimal:
            solution = self._extract_solution(food_vars)
            return {
                'status': 'optimal',
                'foods': solution['foods'],
                'totals': solution['totals'],
                'targets': {
                    'calories': target_calories,
                    'protein': target_protein,
                    'carbs': target_carbs,
                    'fat': target_fat
                }
            }
        else:
            return {
                'status': 'infeasible',
                'message': 'No solution found. Try adjusting targets or tolerance.'
            }
    
    def _extract_solution(self, food_vars: Dict) -> Dict:
        """Extract and calculate nutritional totals from solution"""
        selected_foods = []
        total_cals = 0
        total_prot = 0
        total_carb = 0
        total_fat = 0
        
        for food_id, var in food_vars.items():
            amount = var.varValue
            if amount and amount > 0:
                food_info = self.foods_df[
                    self.foods_df['food_id'] == food_id
                ].iloc[0]
                
                # Calculate per serving
                multiplier = amount / 100
                cals = food_info['calories'] * multiplier
                prot = food_info['protein'] * multiplier
                carb = food_info['carbs'] * multiplier
                fat = food_info['fat'] * multiplier
                
                selected_foods.append({
                    'food_id': food_id,
                    'name': food_info['name'],
                    'amount_g': round(amount, 1),
                    'calories': round(cals, 1),
                    'protein': round(prot, 1),
                    'carbs': round(carb, 1),
                    'fat': round(fat, 1)
                })
                
                total_cals += cals
                total_prot += prot
                total_carb += carb
                total_fat += fat
        
        return {
            'foods': selected_foods,
            'totals': {
                'calories': round(total_cals, 1),
                'protein': round(total_prot, 1),
                'carbs': round(total_carb, 1),
                'fat': round(total_fat, 1)
            }
        }


# Test
if __name__ == "__main__":
    from data_loader import FoodDatabase
    
    # Load data
    db = FoodDatabase()
    foods = db.get_all_foods()
    
    # Create optimizer
    optimizer = NutritionOptimizer(foods)
    
    # Test with sample targets
    result = optimizer.optimize(
        target_calories=2000,
        target_protein=150,
        target_carbs=200,
        target_fat=65,
        tolerance=0.1
    )
    
    print("Optimization Result:")
    print(f"Status: {result['status']}")
    if result['status'] == 'optimal':
        print("\nSelected Foods:")
        for food in result['foods']:
            print(f"  {food['name']}: {food['amount_g']}g")
        print(f"\nTotals: {result['totals']}")
        print(f"Targets: {result['targets']}")
EOFcd ~/Desktop/nutrition_optimizer

# Yedek al
cp src/optimizer.py src/optimizer.py.backup

# Düzeltilmiş versiyonu yaz
cat > src/optimizer.py << 'EOF'
import numpy as np
import pulp
from typing import Dict, List, Tuple
import pandas as pd

class NutritionOptimizer:
    """
    Optimizes daily meal plan using Linear Programming
    to meet nutritional targets within constraints
    """
    
    def __init__(self, foods_df: pd.DataFrame):
        self.foods_df = foods_df
        self.solution = None
        
    def optimize(self, 
                 target_calories: float,
                 target_protein: float,
                 target_carbs: float,
                 target_fat: float,
                 tolerance: float = 0.05) -> Dict:
        """
        Finds optimal food amounts to meet nutritional targets
        
        Args:
            target_calories: Target daily calories
            target_protein: Target protein in grams
            target_carbs: Target carbs in grams
            target_fat: Target fat in grams
            tolerance: Acceptable deviation from targets (5% default)
            
        Returns:
            Dictionary with selected foods and their amounts
        """
        
        # Create optimization problem
        prob = pulp.LpProblem("Nutrition_Optimization", pulp.LpMinimize)
        
        # Decision variables: amount of each food in grams
        food_vars = {}
        for idx, row in self.foods_df.iterrows():
            food_id = row['food_id']
            # Min 0g, Max 500g per food item
            food_vars[food_id] = pulp.LpVariable(
                f"food_{food_id}", 
                lowBound=0, 
                upBound=500
            )
        
        # Objective: Minimize total weight
        prob += pulp.lpSum([food_vars[fid] for fid in food_vars])
        
        # Calculate nutritional values per 100g
        total_calories = pulp.lpSum([
            food_vars[row['food_id']] * row['calories'] / 100
            for idx, row in self.foods_df.iterrows()
        ])
        
        total_protein = pulp.lpSum([
            food_vars[row['food_id']] * row['protein'] / 100
            for idx, row in self.foods_df.iterrows()
        ])
        
        total_carbs = pulp.lpSum([
            food_vars[row['food_id']] * row['carbs'] / 100
            for idx, row in self.foods_df.iterrows()
        ])
        
        total_fat = pulp.lpSum([
            food_vars[row['food_id']] * row['fat'] / 100
            for idx, row in self.foods_df.iterrows()
        ])
        
        # Constraints with tolerance
        prob += total_calories >= target_calories * (1 - tolerance)
        prob += total_calories <= target_calories * (1 + tolerance)
        
        prob += total_protein >= target_protein * (1 - tolerance)
        prob += total_protein <= target_protein * (1 + tolerance)
        
        prob += total_carbs >= target_carbs * (1 - tolerance)
        prob += total_carbs <= target_carbs * (1 + tolerance)
        
        prob += total_fat >= target_fat * (1 - tolerance)
        prob += total_fat <= target_fat * (1 + tolerance)
        
        # Solve
        prob.solve(pulp.PULP_CBC_CMD(msg=0))
        
        # Extract solution
        if prob.status == pulp.LpStatusOptimal:
            solution = self._extract_solution(food_vars)
            return {
                'status': 'optimal',
                'foods': solution['foods'],
                'totals': solution['totals'],
                'targets': {
                    'calories': target_calories,
                    'protein': target_protein,
                    'carbs': target_carbs,
                    'fat': target_fat
                }
            }
        else:
            return {
                'status': 'infeasible',
                'message': 'No solution found. Try adjusting targets or tolerance.'
            }
    
    def _extract_solution(self, food_vars: Dict) -> Dict:
        """Extract and calculate nutritional totals from solution"""
        selected_foods = []
        total_cals = 0
        total_prot = 0
        total_carb = 0
        total_fat = 0
        
        for food_id, var in food_vars.items():
            amount = var.varValue
            if amount and amount > 0:
                food_info = self.foods_df[
                    self.foods_df['food_id'] == food_id
                ].iloc[0]
                
                # Calculate per serving
                multiplier = amount / 100
                cals = food_info['calories'] * multiplier
                prot = food_info['protein'] * multiplier
                carb = food_info['carbs'] * multiplier
                fat = food_info['fat'] * multiplier
                
                selected_foods.append({
                    'food_id': food_id,
                    'name': food_info['name'],
                    'amount_g': round(amount, 1),
                    'calories': round(cals, 1),
                    'protein': round(prot, 1),
                    'carbs': round(carb, 1),
                    'fat': round(fat, 1)
                })
                
                total_cals += cals
                total_prot += prot
                total_carb += carb
                total_fat += fat
        
        return {
            'foods': selected_foods,
            'totals': {
                'calories': round(total_cals, 1),
                'protein': round(total_prot, 1),
                'carbs': round(total_carb, 1),
                'fat': round(total_fat, 1)
            }
        }


# Test
if __name__ == "__main__":
    from data_loader import FoodDatabase
    
    # Load data
    db = FoodDatabase()
    foods = db.get_all_foods()
    
    # Create optimizer
    optimizer = NutritionOptimizer(foods)
    
    # Test with sample targets
    result = optimizer.optimize(
        target_calories=2000,
        target_protein=150,
        target_carbs=200,
        target_fat=65,
        tolerance=0.1
    )
    
    print("Optimization Result:")
    print(f"Status: {result['status']}")
    if result['status'] == 'optimal':
        print("\nSelected Foods:")
        for food in result['foods']:
            print(f"  {food['name']}: {food['amount_g']}g")
        print(f"\nTotals: {result['totals']}")
        print(f"Targets: {result['targets']}")
